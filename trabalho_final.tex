Aplicações e Problemas Computacionais em Matemática Discreta.
João Victor Mendes Freire e Guilherme Locca Salomão
5 de julho de 2019

Introdução
    O que é Matemática Discreta

        A Matemática Discreta é um ramo da matemática que não possui uma definição formal precisa e exata. Ela é descrita como o ramo que estuda conjuntos contáveis, ou seja, conjuntos finitos ou que possuem a mesma cardinalidade do conjunto dos naturais.
        Ao se observar o conjunto dos números reais, por exemplo, podemos escolher dois números arbitrários, como 0 e 1. Entre esses dois números, existe uma infinidade de outros números, e, portando, não podemos considerar 0 o “primeiro" e 1 o “segundo”. O 0,5 existe entre eles. Bem como o 0,05, e o 0,005. Logo, não conseguimos mapear a cardinalidade dos números naturais para cada número real.
        O conjunto dos inteiros é infinito assim como os reais, mas, diferentemente deles, é enumerável. Portanto, podemos mapear a cardinalidade dos naturais neles. 
        Assim sendo, embora contenha infinitos elementos, o conjunto dos inteiros é uma estrutura discreta, de interesse da matemática discreta, ao contrario dos reais, que é uma estrutura contínua.


    Por que é importante?
        Dispositivos digitais estão presentes em inúmeros contextos no mundo contemporâneo. Smartphones, computadores pessoais, servidores, semáforos, sistemas de um banco, os sistemas de um veículo e milhares de outros sistemas são digitais. Devido a isto, são construídos por circuitos lógicos, que funcionam baseados em estruturas discretas.
        A comunicação entre bancos, governos e até mesmo entre pessoas é segura quando se utiliza Criptografia para proteger os dados. A matemática discreta é bastanten importante em se tratando de desenvolver novos e melhores algortimos para criptografar e descriptografar dados privados.
        Além desse aspecto computacional, a matemática discreta oferece as ferramentas para que, por exemplo, um carteiro descubra qual a rota de entregas mais eficiênte.
        Estes são apenas dois exemplos de impactos da matemática discreta na vida de uma pessoa comum. Existem inúmeros outros, e ainda mais para aqueles interessados em aprofundar seus conhecimentos na área de Ciência da Computação.


    Tópicos de Interesse
        Alguns dos principais tópicos em matemática discreta são: teoria dos números, conjuntos, funções, relações, recorrências e teoria dos grafos.
        % detalhar e refinar mais essa parte

    Materiais e Métodos

Capitulo I
    Metodologia
    Resultados e discussões
    Considerações finais

Capitulo II
    Metodologia
    Resultados e discussões
    Considerações finais

Capitulo III: Project Euler - Conjunto de Problemas 3
    O terceiro conjunto de problemas contém os exercícios: Amicable Numbers (Números Amigáveis), 1000-digit Fibonacci Number (Número de Fibonacci de 1000 Dígitos) e Distinct Powers (Potências Distintas).
    Amicable Numbers:
        Metodologia
            Seja soma_divisores(n) a soma de todos os divisores de n (números menores que n que o dividem com resto 0). Sejam a, b inteiros diferentes. Se soma_divisores(a) = b. e soma_divisores(b) = a, dizemos que a e b são números amigáveis. O exercício em questão pergunta qual a soma de todos on números amigáveis de 1 à 10000.
            O exercício requer conhecimento da definição de divisível, e exigiu que se pensasse numa forma de não repetir os números encontrados.
        Resultados e discussões
            # Dado um número inteiro x, a função retorna a soma dos divisores inteiros de x
            def soma_divisores(x):
                soma = 0;
                for i in range(1, x // 2 + 1):
                    if x % i == 0:
                        soma = soma + i
                return soma

            # Dado um número inteiro x, a função retorna a soma dos números amigáveis no intervalo [1, x)
            def soma_amigaveis(x):
                soma = 0
                a = 1
                while a < x:
                    b = soma_divisores(a)
                    # se b > a, para que não se calcule um número amigável que já apareceu
                    if b > a and soma_divisores(b) == a:
                        soma = soma + a + b
                    a = a + 1
                return soma

            res = soma_amigaveis(10000)
            print(res)
            A resposta encontrada nessa solução foi 31626, que é a mesma presente no site que contém as respostas para a lista.
        Considerações finais
            A solução do problema é bem direto ao ponto: para cada número de [1, x), calcule a soma de seus divisores, e depois calcule a soma dos divisores desse resultado. Se forem iguais, e b for maior que a, adicione a soma deles na soma acumulada.
            Quanto a dificuldade de não se repetir números já calculados, basta que nós coloquemos a limitação que b > a, assim garantindo que, se b < a, a + b já foi adicionado a soma quando o número que estavamos testando era a.

    1000-digit Fibonacci Number:
        Metodologia
            A sequência de Fibonacci é definida por uma relação de recorrência, onde Fib(n) = Fib(n - 1) + Fib(n - 2), sendo Fib(1) = Fib(2) = 1 os números iniciais.
            O problema pedia para encontrar qual o índice do primeiro número da sequência de Fibonacci que possui 1000 dígitos.
            A busca pela solução começou pensando na forma de calcular quantos digitos tem um número, e rapidamente chegamos a conclusão que se dividissemos o número várias vezes por 10 até que sobrasse apenas 0, teriamos o número de casas. Depois, partimos para a solução que, diferentemente do problema anterior, teve que ser alterada por razões de performance.
        Resultados e discussões
            A solução para o problema pode ser simplificada a função num_digitos(x), que encontra o valor usando o lag10 de x. Para o problema de resolver Fib(x), encontramos ao todo 3 soluções.
            A primeira, fib(x), partiu da definição da sequência. Para valores pequenos, a solução resolve o problema, mas o tempo de solução é O(2^n), que torna ela completamente inviável para números como o que possui 1000 digitos.
            Tento em vista o tempo exponencial da anterior, utilizamos os conhecimentos de recorrência, e encontramos a fórmula fechada presente em fib_fechado(x). Essa função resolve o problema do x-ésimo Fibonacci em tempo linear. A primeira vista ele parece ideal, mas o número de vezes que se eleva os números (da ordem de x) faz com que os valores causem um overflow. Portanto, a velocidade é boa, mas os números cressem rápido demais para a memória disponível para um inteiro.
            Por fim, encontramos uma solução que resolve em tempo linear com uso constante de memória. A função fib_defiitivo(x) resolve o problema usando três variáveis auxiliares, e o loop realiza O(x) iterações.

            from math import sqrt, floor, log10

            # Dado um inteiro x, calcula o número de digitos
            def num_digitos(x):
                return floor(1 + log10(x))

            # Dado inteiro x, returna o x-ésimo valor da sequência de Fibonacci
            # Solução não ideal para o problemas, pois calcula fib(x) em tempo exponencial
            def fib(x):
                if x == 1 or x == 2:
                    return 1
                else:
                    return fib(x - 1) + fib(x - 2) 

            # Dado inteiro x, returna o x-ésimo valor da sequência de Fibonacci
            # Solução melhor, pois calcula fib(x) em tempo constante (linear se 
            # considerarmos o número de multiplicações que vão ocorrer para elevar
            # a e b a x). Foi obtida usando o conceito de fórmula fechada para 
            # recorrências
            def fib_fechado(x):
                raiz5 = sqrt(5)
                a = (1 + raiz5) / 2
                b = (1 - raiz5) / 2
                return (a ** x - b ** x) / raiz5

            # Dado inteiro x, returna o x-ésimo valor da sequência de Fibonacci
            # Solução definitiva, pois calcula fib(x) em tempo linear, e possui 
            # um uso de memória constante
            def fib_definitivo(x):
                a = 1
                b = 0
                while x > 1:
                    aux = a
                    a = a + b
                    b = aux
                    x = x - 1
                return a

            # Dado um inteiro x, retorna o índice do número de Fibonacci 
            # que possui x digitos
            def x_digit_Fibonacci(x):
                i = 1
                while num_digitos(fib_definitivo(i)) < x:
                    i = i + 1
                return i

            res = x_digit_Fibonacci(1000)
            print(res)

            A resposta final encontrada foi que o 4782-ésimo número de Fibonacci é o primeiro a possuir 1000 dígitos.
        Considerações finais
            Este exercício exigiu bastante criatividade na hora de encontrar uma forma eficiênte de resolver o problema de Fibonacci, que era o maior gargalo da solução, já que x_digit_Fibonacci(x) e num_digitos(x) possuem tempo de execução da ordem de n e log10 n, respectivamente. 
    Distinct Powers:
        Metodologia
            O problema consistia em descobrir de quantos elementos diferentes existem numa lista com os resultados das possíveis combinações de a^b, com 2 <= a <= 100 e com 2 <= b <= 100.
        Resultados e discussões
            # Dado dois inteiros low, high, calcula o número de resultados diferentes 
            # das possíveis combinações de a ** b (elevado), com a, b pertencentes a [low, high]
            def num_combinacoes(low, high):
                lista_combinacoes = []
                for a in range(low, high + 1):
                    for b in range(low, high + 1):
                        aux = a**b
                        if aux not in lista_combinacoes:
                            lista_combinacoes.append(aux)
                
                return len(lista_combinacoes)

            res = num_combinacoes(2, 100)
            print(res)

            A resposta encontrada foi 9183, que está de acordo com a presente na lista de soluções.

        Considerações finais
            Assim como no primeiro exercício deste conjunto, a solução foi bem direto ao ponto, calculando todas as possíveis combinações de a^b, em tempo O(n^2), onde n é o número de elemento no conjunto [low, high]; depois, colocando na lista apenas os que ainda não estão presentes nela e contando quantos elementos existem nela no final. A solução esta longe de ser a mais eficiente, mas consegue resolver o problema quase instantâneamente em casos relativamente pequenos, como o pedido.

Capitulo IV: Project Euler - Conjunto de Problemas 4
    O quarto conjunto de problemas contém os exercícios: Circular Primes (Primos Circulares), Goldbach's other conjecture (A outra conjectura de Goldbach) e Consecutive Prime Sum (Soma de Primos Consecutivos).

    Circular Primes:
        Metodologia
            Um número é chamado de Primo Circular se as rotações dos seus digitos também são primos. O problema em questão procura saber quantos números primos circulares existem até um milhão.
        Resultados e discussões
            A solução começou fazendo uma função que retorna True se um dado número é primo, e False se não. Depois, partimos para fazer uma função que preenche uma lista de tamanho n com True/False dependendo se aquele índice é um número primo ou não.
            O próximo passo foi descobrir se as rotações com os dígitos de um número são primos ou não. Devido as facilidades de se usar strings em Python, converter o número pra uma string e fazer algumas manipulações de fatiamento tornaram essa tarefa bem simples.
            Por fim, a resolução final consistem em repetir as verificações para todos os primos obtidos na função lista_primos. Infelizmente, a solução é completamente inviável para números muito grandes, como o 1000000 pedido pelo exercício. Então, buscamos por formas mais eficientes de se separar os números primos, e encontramos o Crivo de Eratóstenes, um algoritmo bastante eficiente para encontrar números primos. Felizmente, esse algoritmo fez com que nossa solução resolve num tempo viável, embora encontramos versões que agilizam ainda mais ao nem considerar primos que contém certos dígitos como 2 e 5.
            from math import ceil

            # Dado um inteiro x, retorna True se for primo e False caso contrário
            def primo(x):
                if x == 2:
                    return True
                elif x % 2 == 0 or x < 2:
                    return False
                else:
                    divisivel = False
                    i = 2
                    while i <= x/2 and not divisivel:
                        if x % i == 0:
                            divisivel = True
                        i = i + 1
                return not divisivel

            # Dado um limitante superior x, retorna a lista de tamanho x com
            # True se o número com aquele índice é primo e False caso contrário
            def lista_primos(x):
                lista = []
                for i in range(0, x):
                    lista.append(primo(i))
                return lista

            # Algotimo mais eficiente para gerar uma lista de primos
            # Dado um inteiro x, retorn uma lista com True se aquele 
            # índice é de um primo, False caso contrário
            def sieve_eratosthenes(x):
                arredonda = lambda x, primo: int(ceil(float(x) / primo))

                primos = [True] * x
                primos[0] = False
                primos[1] = False
                lista_primo = []

                for primo_atual in range(2, x):
                    if not primos[primo_atual]:
                        continue
                    lista_primo.append(primo_atual)
                    for m in range(2, arredonda(x, primo_atual)):
                        primos[m * primo_atual] = False
                return primos

            # Dado um valor primo x, verifica se as rotações dos dígitos 
            # de x estão contidas numa lista booleana de primos
            def primo_circular(x, lista_de_primos):
                x = str(x) # convertendo para string para facilitar rotação
                for i in range(0, len(x)):
                    rotacionado = x[i:len(x)] + x[0:i]
                    if not lista_de_primos[int(rotacionado)]:
                        return False
                return True

            # Dado um limitante superior inteiro x, retorna quantos primos
            # circulares existem em [1, x)
            def quantos_primos_circulares(x):
                quantidade = 0
                primos = sieve_eratosthenes(x)
                for i in range(0, x):
                    if primo_circular(i, primos):
                        quantidade = quantidade + 1
                return quantidade

            res = quantos_primos_circulares(1000000)
            print(res)

            A resposta encontrada foi 55.

        Considerações finais
            Esse problema foi bastante complicado, principalmente no momento de obtenção da solução mais eficiente para encontrar números primos. Acabamso aprendendo como usar funções lamba em Python, e entendemos melhor como fatiar Strings.
    
    Goldbach's other conjecture:
        Metodologia
            A solução do problema se iniciou com a reutilização do Crivo de Eratóstenes do exercício anterior, devido a sua grande eficiência em encontrar número primos. Depois, a solução surgiu da ideia de simplesmente testar o primeiro número que não possuia uma raíz inteira que satisfazia a equação numero = primo + 2 * outro_número^2.
        Resultados e discussões
            from math import sqrt, ceil

            def sieve_eratosthenes(x):
                arredonda = lambda x, primo: int(ceil(float(x) / primo))

                primos = [True] * x
                primos[0] = False
                primos[1] = False
                lista_primo = []

                for primo_atual in range(2, x):
                    if not primos[primo_atual]:
                        continue
                    lista_primo.append(primo_atual)
                    for m in range(2, arredonda(x, primo_atual)):
                        primos[m * primo_atual] = False
                return lista_primo

            # Encontra o primeiro número que não obedesce a conjectura
            # de Goldbach
            def goldbach_conjecture():
                lista_primos = sieve_eratosthenes(1000000)
                num = 1
                não_encontrou = True
                while não_encontrou:
                    num += 2
                    i = 0
                    não_encontrou = False
                    while num >= lista_primos[i]:
                        a = num - lista_primos[i]
                        # quando essa condição não é satisfeita, o número não é quadrado perfeito
                        if sqrt(a/2) == int(sqrt(a/2)):
                            não_encontrou = True
                            break
                        i += 1
                return num

            res = goldbach_conjecture()
            print(res)
            A resposta encontrada foi 5777, que condiz com a lista de respostas.

        Considerações finais
            A solução desse exercício foi bastante direto ao ponto, e exigiu apenas perceber a condição que necessitava que raíz( (número - primo) / 2) tem que ser um quadrado perfeito.
    
    Consecutive Prime Sum:
        Metodologia
            O problema pedia que, dado um inteiro x, fosse encontrada a maior sequência de números primos consecutivos de forma que a soma seja a maior possível e seja um primo inferior ao dado x.
            A solução se iniciou reutilizando o Crivo de Eratóstenes, que foi utilizado no primeiro exercício desse conjunto, levemente modificado, de forma a retornar tanto uma lista de primos de 1..x e a lista de primalidade (True para indices primos, False para compostos).
            A partir daí, partimos para buscar a solução do problema.
        Resultados e discussões
            from math import ceil

            def sieve_eratosthenes(x):
                arredonda = lambda x, primo: int(ceil(float(x) / primo))

                primos = [True] * x
                primos[0] = False
                primos[1] = False
                lista_primo = []

                for primo_atual in range(2, x):
                    if not primos[primo_atual]:
                        continue
                    lista_primo.append(primo_atual)
                    for m in range(2, arredonda(x, primo_atual)):
                        primos[m * primo_atual] = False
                return lista_primo, primos

            # Dado um inteiro x, retorna a maior sequência de soma de primos, tal que a soma é inferior a x
            def maior_soma_primos(x):
                maior = 0
                lista_primo, é_primo = sieve_eratosthenes(x)
                consecutivo = 0
                for i in range(len(lista_primo)):
                    soma = lista_primo[i]
                    consec = 1
                    for j in range(i + 1, len(lista_primo)):
                        soma += lista_primo[j]
                        consec += 1
                        if soma >= len(é_primo):
                            break
                        if é_primo[soma] and consec > consecutivo:
                            maior = soma
                            consecutivo = consec
                return maior

            res = maior_soma_primos(1000000)
            print(res)

            A resposta encontrada foi 997651.

        Considerações finais
            A solução deste exercício se mostrou bastante complicada. Depois de muito tempo buscando uma forma eficiente de encontrar a maior sequencia que ao mesmo tempo resulta na maior soma, acabamos busca ajuda na internet, para procurar sugestões de algoritmos e até mesmo algumas soluções. Fizemos adaptações para seguir o mesmo estilo de soluções anteriores, e acabamos chegando num algoritmo bastante rápido para a solução do problema.

Capitulo V
    Metodologia
    Resultados e discussões
    Considerações finais

Referências
    Discrete Mathematics - Wikipédia, consulta em 30 de junho de 2019
    Sieve of Eratosthenes - Wikipédia, consulta em 6 de julho de 2019