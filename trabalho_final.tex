\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstset{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    literate=
      {á}{{\'a}}1 {é}{{\'e }}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
      {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
      {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
      {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
      {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
      {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
      {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
      {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
      {Ã}{{\~A}}1 {ã}{{\~a}}1 {Õ}{{\~O}}1 {õ}{{\~o}}1
      {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
      {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
      {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
      {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
      {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}

\title{Aplicações e Problemas Computacionais em Matemática Discreta}
\author{Guilherme Locca Salomão, João Victor Mendes Freire \\e Renan Dantas Pasquantonio }
\date{7 de julho de 2019}

\begin{document}

\maketitle

\section{Introdução}
    \subsection{O que é Matemática Discreta}
    
    A Matemática Discreta é um ramo da matemática que não possui uma definição formal precisa e exata. Ela é descrita como o ramo que estuda conjuntos contáveis, ou seja, conjuntos finitos ou que possuem a mesma cardinalidade do conjunto dos naturais.\\
    Ao se observar o conjunto dos números reais, por exemplo, podemos escolher dois números arbitrários, como 0 e 1. Entre esses dois números, existe uma infinidade de outros números, e, portando, não podemos considerar 0 o “primeiro" e 1 o “segundo”. O 0,5 existe entre eles. Bem como o 0,05, e o 0,005. Logo, não conseguimos mapear a cardinalidade dos números naturais para cada número real.\\
    O conjunto dos inteiros é infinito assim como os reais, mas, diferentemente deles, é enumerável. Portanto, podemos mapear a cardinalidade dos naturais neles. \\
    Assim sendo, embora contenha infinitos elementos, o conjunto dos inteiros é uma estrutura discreta, de interesse da matemática discreta, ao contrario dos reais, que é uma estrutura contínua.
    
    
    \subsection{Por que é importante?}
    Dispositivos digitais estão presentes em inúmeros contextos no mundo contemporâneo. Smartphones, computadores pessoais, servidores, semáforos, sistemas de um banco, os sistemas de um veículo e milhares de outros sistemas são digitais. Devido a isto, são construídos por circuitos lógicos, que funcionam baseados em estruturas discretas.\\
    A comunicação entre bancos, governos e até mesmo entre pessoas é segura quando se utiliza Criptografia para proteger os dados. A matemática discreta é bastanten importante em se tratando de desenvolver novos e melhores algortimos para criptografar e descriptografar dados privados.\\
    Além desse aspecto computacional, a matemática discreta oferece as ferramentas para que, por exemplo, um carteiro descubra qual a rota de entregas mais eficiênte.\\
    Estes são apenas dois exemplos de impactos da matemática discreta na vida de uma pessoa comum. Existem inúmeros outros, e ainda mais para aqueles interessados em aprofundar seus conhecimentos na área de Ciência da Computação.\\
    
    \subsection{Tópicos de Interesse}
    Alguns dos principais tópicos em matemática discreta são: teoria dos números, conjuntos, funções, relações, recorrências e teoria dos grafos.
    % detalhar e refinar mais essa parte
    
    \subsection{Organização do Documento}
    O documento foi estruturado da seguinte forma: em cada capítulo, temos um conjunto de exercícios computacionais propostos pelo Professor. Para cada exercício, temos uma seção que introduz o problema e descreve o processo de resolução.\\
    Depois, temos uma seção com os códigos de resolução. E, por fim, temos uma de considerações finais, na qual explicamos eventuais dificuldades e algumas análises de tempo e espaço dos algoritmos.\\
    
    \subsection{Materiais e Métodos}
    Os algoritmos foram desenvolvidos em duas plataformas, sendo a primeira deles utilizando a distribuição Linux Manjaro, um editor de texto em conjunto com o terminal. Foram utilizadas as Linguagens Python, na versão 3.7, e a linguagem C. A segunda plataforma utilizou o sistema operacional MacOS, também utilizou um editor de texto (Visual Studio Code) em conjunto com o terminal. Na segunda, as atividades foram resolvidas usando apenas a linguagem Python 3.7.
\clearpage

\section{Capítulo I: Project Euler - Conjunto 1}
O primeiro conjunto de problemas contém os exercícios: 100001st Prime Number, Special Pyhtagorian Triplet e Distinct Powers.
    \subsection{10001st prime number }
       
        \subsubsection{Metodologia} 
        Um primo é definido por ter apenas dois divisores, 1 e ele mesmo, nesse sentido, a solução seria uma aplicação direta da definição
       
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex1.py} % código
        
        A resposta encontrada foi 104.743 como conferido no arquivo de respostas fornecido.
        
        \subsubsection{Considerações finais}
        Este tem uma solução bem direta porém pouco eficiente, certas escolhas como pular a verificação de numeros pares definitivamente reduzem o tempo de execução mas ainda sim não é possivel deixa-lo instantâneo.
        
    \subsection{Special Pyhtagorian Triplet}
        
        \subsubsection{Metodologia}
        Uma tripla pitagorica é quando a soma dos quadrados de dois numeros é igual ao quadrado de um terceiro número, ou seja $a^2+b^2=c^2$. Para resolver esse problema foi usada a logica de que, C tem que ser o complemento da soma de A e B, e então de forma interativa foi testada as possibilidades dessa combinação.
        
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex2.py} % código
        
        A saida do programa foi 31875000, compativel com a resposta no arquivo fornecido.
        
        \subsubsection{Considerções finais}
        A solução desse problema foi difícil de se traduzir para codigo poís há varias soluções possiveis porém cada uma tem sua dificuldade de implementação, entretanto, a "ideia" da solução foi facil de se chegar.
        
    \subsection{Longest Collatz Sequence}
        
        \subsubsection{Metodologia}
        Uma sequencia collatz é uma sequêcia iterativa onde considerando a sequêcia iniciando em um numero $n$, se $n$ for par então $n = \frac{n}{2}$, se $n$ for impar então, $n = 3n + 1$, até chegar ao caso base de $N = 1$. Para resolver esse problema foi uma aplicação direta dessa definição e então atualizar qual seria a maior sequência sempre que uma maior for encontrada.
        
        \subsubsection{Resultados e Discussões}
\lstinputlisting[language=Python]{ex3.py} % código
        O retorno desse algoritmo foi de 837799, igual ao resultado fornecido no arquivo de respostas
        
        \subsubsection{Considerações finais}
        A solução desse problema foi direta porem achar detalhes que a otimizaçem foi difícil, a única opção de otimização que pude encontrar foi a de pular os números pares pois estes sempre retornavam as sequências mais curtas.
\clearpage

\section{Capítulo II: Project Euler - Conjunto 2}
O segundo conjunto de problemas contém os exercícios: Summation of primes, Highly Divisible Triangular Number e Power Digit Sum.
    \subsection{Summation of primes}
        
        \subsubsection{Metodologia} 
        A solução desse exercicio é direta e simples, achar todos os primos e então soma-los. Foi utilizado o Crivo de Eratóstenes para de forma mais eficiente encontrar todos os número primos até dois milhões e então somalos.
        
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex4.py} % código
        A saida do programa foi 142913828922 como no arquivo de respostas fornecido
        
        \subsubsection{Conclusões finais} 
        Para realizar esse programa, era necessário um algortimo para achar números primos mais eficiente que a checagem pela definição, portanto a escolha do crivo, além disso foi mais incentivado o uso de tal algoritmo por temos um valor limite.
    \subsection{Highly Divisible Triangular Number}
        
        \subsubsection{Metodologia}
        Um número triangular na posição N é a soma de todos os naturais menores que N, pensando nisso, foi necessário criar uma forma para encontrar o número triangular de posição N, e então criar uma forma de testar seus divisores.
        
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=C]{ex5.c} % código
        O retorno desse algoritmo foi de 76576500 correspondendo com a resposta fornecida
        
        \subsubsection{Considerações finais}
        A soluçao desse problema era bem direta e facil de se implementar, o que tornou viavel usar a linguagem C para isso pois ela poderia realizar em um menor tempo as operações em comparação a python. Além disso outra otimização foi o uso do numero anterior para calcular o numero da posição atual pois assim se tornava um operção simples o que acelerava o processo.
        
    \subsection{Power Digit Sum}
       
        \subsubsection{Metodologia}
        Um número triangular na posição N é a soma de todos os naturais menores que N, pensando nisso, foi necessário criar uma forma para encontrar o número triangular de posição N, e então criar uma forma de testar seus divisores.
        
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex6.py} % código
        O resultado desse algoritmo foi 1366 igual ao resultado fornecido no arquivo de respostas
        
        \subsubsection{Considerações finais}
        A solução desse problema é simples porém é necessário uma estrutura muito flexível para comportar o número $2^1000$,ja que esse requer cerca de 1000 bits para armazenar, então, ao contrario da minha decisão inicial, foi necessário o uso de python para essa operação.
\clearpage

\section{Capítulo III: Project Euler - Conjunto 3}
O terceiro conjunto de problemas contém os exercícios: Amicable Numbers (Números Amigáveis), 1000-digit Fibonacci Number (Número de Fibonacci de 1000 Dígitos) e Distinct Powers (Potências Distintas).
    \subsection{Amicable Numbers}
        
        \subsubsection{Metodologia}
        Seja $soma\_divisores(n)$ a soma de todos os divisores de $n$ (números menores que $n$ que o dividem com resto 0). Sejam $a, b$ inteiros diferentes. Se $soma\_divisores(a) = b$, e $soma\_divisores(b) = a$, dizemos que $a$ e $b$ são números amigáveis. O exercício em questão pergunta qual a soma de todos on números amigáveis de 1 à 10000.\\
        O exercício requer conhecimento da definição de divisível, e exigiu que se pensasse numa forma de não repetir os números encontrados.
        
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex21.py} % código
        A resposta encontrada nessa solução foi 31626, que é a mesma presente no site que contém as respostas para a lista.
        
        \subsubsection{Considerações finais}
        A solução do problema é bem direto ao ponto: para cada número de $[1, x)$, calcule a soma de seus divisores, e depois calcule a soma dos divisores desse resultado. Se forem iguais, e $b$ for maior que $a$, adicione a soma deles na soma acumulada.\\
        Quanto a dificuldade de não se repetir números já calculados, basta que nós coloquemos a limitação que $b > a$, assim garantindo que, se $b < a$, $a + b$ já foi adicionado a soma quando o número que estavamos testando era $a$.

    \subsection{1000-digit Fibonacci Number}
        
        \subsubsection{Metodologia}
        A sequência de Fibonacci é definida por uma relação de recorrência, onde $Fib(n) = Fib(n - 1) + Fib(n - 2)$, sendo $Fib(1) = Fib(2) = 1$ os números iniciais.
        O problema pedia para encontrar qual o índice do primeiro número da sequência de Fibonacci que possui 1000 dígitos.\\
        A busca pela solução começou pensando na forma de calcular quantos digitos tem um número, e rapidamente chegamos a conclusão que se dividissemos o número várias vezes por 10 até que sobrasse apenas 0, teriamos o número de casas. Depois, partimos para a solução que, diferentemente do problema anterior, teve que ser alterada por razões de performance.
        
        \subsubsection{Resultados e discussões}
        A solução para o problema pode ser simplificada a função $num\_digitos(x)$, que encontra o valor usando o $log10$ de $x$. Para o problema de resolver $Fib(x)$, encontramos ao todo 3 soluções.\\
        A primeira, $fib(x)$, partiu da definição da sequência. Para valores pequenos, a solução resolve o problema, mas o tempo de solução é $O(2^n)$, que torna ela completamente inviável para números como o que possui 1000 digitos.\\
        Tento em vista o tempo exponencial da anterior, utilizamos os conhecimentos de recorrência, e encontramos a fórmula fechada presente em $fib\_fechado(x)$. Essa função resolve o problema do x-ésimo Fibonacci em tempo linear. A primeira vista ele parece ideal, mas o número de vezes que se eleva os números (da ordem de x) faz com que os valores causem um overflow. Portanto, a velocidade é boa, mas os números cressem rápido demais para a memória disponível para um inteiro.\\
        Por fim, encontramos uma solução que resolve em tempo linear com uso constante de memória. A função $fib\_definitivo(x)$ resolve o problema usando três variáveis auxiliares, e o loop realiza $O(x)$ iterações.
\lstinputlisting[language=Python]{ex25.py} % código
        A resposta final encontrada foi que o 4782-ésimo número de Fibonacci é o primeiro a possuir 1000 dígitos.
        
        \subsubsection{Considerações finais}
        Este exercício exigiu bastante criatividade na hora de encontrar uma forma eficiênte de resolver o problema de Fibonacci, que era o maior gargalo da solução, já que $x\_digit\_Fibonacci(x)$ e $num\_digitos(x)$ possuem tempo de execução da ordem de $n$ e $log10 n$, respectivamente.
        
    \subsection{Distinct Powers}
        
        \subsubsection{Metodologia}
        O problema consistia em descobrir de quantos elementos diferentes existem numa lista com os resultados das possíveis combinações de $a^b$, com $2 \leq a \leq 100$ e com $2 \leq b \leq 100$.
        
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex29.py} % código
        A resposta encontrada foi 9183, que está de acordo com a presente na lista de soluções.
        
        \subsubsection{Considerações finais}
        Assim como no primeiro exercício deste conjunto, a solução foi bem direto ao ponto, calculando todas as possíveis combinações de $a^b$, em tempo $O(n^2)$, onde $n$ é o número de elemento no conjunto [low, high]; depois, colocando na lista apenas os que ainda não estão presentes nela e contando quantos elementos existem nela no final. A solução esta longe de ser a mais eficiente, mas consegue resolver o problema quase instantâneamente em casos relativamente pequenos, como o pedido.
\clearpage

\section{Capítulo IV: Project Euler - Conjunto 4}
O quarto conjunto de problemas contém os exercícios: Circular Primes (Primos Circulares), Goldbach's other conjecture (A outra conjectura de Goldbach) e Consecutive Prime Sum (Soma de Primos Consecutivos).
    
    \subsection{Circular Primes}
        
        \subsubsection{Metodologia}
        Um número é chamado de Primo Circular se as rotações dos seus digitos também são primos. O problema em questão procura saber quantos números primos circulares existem até um milhão.
        
        \subsubsection{Resultados e discussões}
        A solução começou fazendo uma função que retorna True se um dado número é primo, e False se não. Depois, partimos para fazer uma função que preenche uma lista de tamanho n com True/False dependendo se aquele índice é um número primo ou não.\\
        O próximo passo foi descobrir se as rotações com os dígitos de um número são primos ou não. Devido as facilidades de se usar strings em Python, converter o número pra uma string e fazer algumas manipulações de fatiamento tornaram essa tarefa bem simples.\\
        Por fim, a resolução final consistem em repetir as verificações para todos os primos obtidos na função $lista\_primos$. Infelizmente, a solução é completamente inviável para números muito grandes, como o 1000000 pedido pelo exercício. Então, buscamos por formas mais eficientes de se separar os números primos, e encontramos o Crivo de Eratóstenes, um algoritmo bastante eficiente para encontrar números primos. Felizmente, esse algoritmo fez com que nossa solução resolve num tempo viável, embora encontramos versões que agilizam ainda mais ao nem considerar primos que contém certos dígitos como 2 e 5.
\lstinputlisting[language=Python]{ex35.py} % código
        A resposta encontrada foi 55.
        
        \subsubsection{Considerações finais}
        Esse problema foi bastante complicado, principalmente no momento de obtenção da solução mais eficiente para encontrar números primos. Acabamos aprendendo como usar funções $lambda$ em Python, e entendemos melhor como fatiar Strings.
        
    \subsection{Goldbach's other conjecture}
        
        \subsubsection{Metodologia}
        A solução do problema se iniciou com a reutilização do Crivo de Eratóstenes do exercício anterior, devido a sua grande eficiência em encontrar número primos. Depois, a solução surgiu da ideia de simplesmente testar o primeiro número que não possuia uma raíz inteira que satisfazia a equação $numero = primo + 2 * outro\_numero^2$.
       
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex40.py} % código
        A resposta encontrada foi 5777, que condiz com a lista de respostas.
        
        \subsubsection{Considerações finais}
        A solução desse exercício foi bastante direto ao ponto, e exigiu apenas perceber a condição que necessitava que $\sqrt{\frac{(numero - primo)}{2})}$ tem que ser um quadrado perfeito.
        
    \subsection{Consecutive Prime Sum}
        
        \subsubsection{Metodologia}
        O problema pedia que, dado um inteiro $x$, fosse encontrada a maior sequência de números primos consecutivos de forma que a soma seja a maior possível e seja um primo inferior ao dado $x$.\\
        A solução se iniciou reutilizando o Crivo de Eratóstenes, que foi utilizado no primeiro exercício desse conjunto, levemente modificado, de forma a retornar tanto uma lista de primos de 1..x e a lista de primalidade (True para indices primos, False para compostos).\\
        A partir daí, partimos para buscar a solução do problema.
        
        \subsubsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex50.py} % código
        A resposta encontrada foi 997651.
        
        \subsubsection{Considerações finais}
        A solução deste exercício se mostrou bastante complicada. Depois de muito tempo buscando uma forma eficiente de encontrar a maior sequencia que ao mesmo tempo resulta na maior soma, acabamos busca ajuda na internet.\\
        Procurando sugestões de algoritmos e até mesmo algumas soluções, fizemos adaptações para seguir o mesmo estilo de soluções anteriores, e acabamos chegando num algoritmo bastante rápido para a solução do problema.
\clearpage

\section{Capítulo V: Knight's Tour}
    \subsection{Metodologia}
    O problema do Passeio do Cavalo, ou Knight's Tour, consiste em, dado um tabuleiro e uma posição inicial de um cavalo, fazer com que se visite todas as outras casas, sem repetição. Deve-se respeitar as regras de movimentação do xadrez.
    A regra de Warnsdorff é uma heurisica bastante utilizada na resolução do problema. Ela diz:
        \begin{itemize}
            \item Inicie de uma posição qualquer do tabuleiro
            \item Sempre mova para um quadrado adjacente não visitado, isto é que o cavalo pode visitar, que tenha grau mínimo, ou seja, que tenha o menor número de vizinhos não visitados.
        \end{itemize}
    Para resolução desse problema, foi sugerido o seguinte algoritmo:
        \begin{enumerate}
            \item Seja P uma posição inicial do tabuleiro
            \item Marque P com o movimento número 1
            \item Para cada número de movimento de 2 até o número de posições do tabuleiro faça:
                \begin{enumerate}
                    \item Seja S o conjunto das posições acessíveis de P
                    \item Seja P a posição em S com mínima acessibilidade
                    \item Marque a posição P com o número do movimento atual
                \end{enumerate}
            \item Retorne a matriz marcada em que cada posição terá o número do movimento
        \end{enumerate}

    \subsection{Resultados e discussões}
\lstinputlisting[language=Python]{ex_kt.py} % código

    \subsection{Considerações finais}
    O problema Knight's Tour foi bastante complicado de resolver, principalemente pelo uso de árvores de busca. Tivemos que recorer a internet para buscar uma solução. Encontramos uma bastante simples e elegante, que encapsula todo o problema numa única classe e em 5 métodos. A solução resolve o problema de forma recursiva, o que por um lado facilida partir da definição do problema e o entendimento dela. Por outro lado, ela consome mais recursos por colocar as chamadas na pilha de execução.\\
    A solução encontrada resolve um tabuleiro 8x8 em 0.0032131s, resolve um 16x16 em 0.0397682s e um 31x31 em 0.0807571s. Infelizmento, ao realizar o salto de 31x31 para 32x32, a solução recursiva não consegue resolver o problema, pois estoura a pilha de recursão.
\clearpage

\section{Referências}
    \begin{itemize}
      \item \href{https://en.wikipedia.org/wiki/Discrete_mathematics}{Discrete Mathematics - Wikipédia, consulta em 30 de junho de 2019}
      \item \href{https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes}{Sieve of Eratosthenes - Wikipédia, consulta em 6 de julho de 2019}
      \item \href{https://github.com/nayuki/Project-Euler-solutions/blob/master/Answers.txt}{Lista de soluções (cedida pelo professor), última consulta em 7 de julho de 2019}
      \item \href{http://blog.justsophie.com/algorithm-for-knights-tour-in-python/}{Site com a solução do Passeio do Cavalo, consulta em 7 de julho de 2019}
    \end{itemize}

\end{document}
